import pandas as pd
import numpy as np
from metrics import cagr, sharpe, sortino, max_drawdown, volatility

class Backtester:
    """
    Universal backtester: expects a dataframe with:
      - 'Adj Close' (from data_loader)
      - 'Signal' (from a strategy: -1, 0, +1)
    Handles slippage and transaction costs.
    """

    def __init__(self, df: pd.DataFrame, initial_capital: float = 10000.0,
                 slippage_bps: float = 0.0, fee_bps: float = 0.0):
        self.df = df.copy()
        self.initial_capital = initial_capital
        self.slippage_bps = slippage_bps
        self.fee_bps = fee_bps

        # Outputs
        self.returns = None
        self.strategy_returns = None
        self.equity_curve = None
        self.metrics = {}

    def run(self):
        # ---------------- SAFETY CHECKS ----------------
        if self.df.empty:
            raise ValueError("Input DataFrame is empty â€” no data to backtest.")

        if "Adj Close" not in self.df.columns:
            raise ValueError("DataFrame must contain 'Adj Close' column.")

        if "Signal" not in self.df.columns:
            raise ValueError("DataFrame must contain 'Signal' column generated by a strategy.")

        # ---------------- PREPARE DATA ----------------
        df = self.df.sort_index().copy()

        # Ensure numeric & fill missing
        df["Adj Close"] = pd.to_numeric(df["Adj Close"], errors="coerce").ffill()
        df.dropna(subset=["Adj Close"], inplace=True)


        df["Signal"] = pd.to_numeric(df["Signal"], errors="coerce").fillna(0)

        # Market returns
        df["Ret"] = df["Adj Close"].pct_change().fillna(0.0)

        # Position = yesterday's signal (avoid lookahead bias)
        df["Position"] = df["Signal"].shift(1).fillna(0.0)

        # ---------------- TRANSACTION COSTS ----------------
        df["Turnover"] = (df["Position"] - df["Position"].shift(1).fillna(0)).abs()
        cost_per_trade = (self.slippage_bps + self.fee_bps) / 10000.0

        # ---------------- STRATEGY RETURNS ----------------
        df["Strat_Ret_Gross"] = df["Position"] * df["Ret"]
        df["Strat_Ret_Net"] = df["Strat_Ret_Gross"] - df["Turnover"] * cost_per_trade

        # ---------------- EQUITY CURVE ----------------
        df["Equity"] = (1.0 + df["Strat_Ret_Net"]).cumprod() * self.initial_capital

        # Save internal state
        self.df = df
        self.returns = df["Ret"]
        self.strategy_returns = df["Strat_Ret_Net"]
        self.equity_curve = df["Equity"]

        # ---------------- METRICS ----------------
        try:
            self.metrics = {
                "Final Equity": float(self.equity_curve.iloc[-1]) if not self.equity_curve.empty else None,
                "CAGR": round(float(cagr(self.equity_curve)), 4) if not self.equity_curve.empty else None,
                "Sharpe": round(float(sharpe(self.strategy_returns)), 4) if self.strategy_returns is not None else None,
                "Sortino": round(float(sortino(self.strategy_returns)), 4) if self.strategy_returns is not None else None,
                "Max Drawdown": round(float(max_drawdown(self.equity_curve)), 4) if not self.equity_curve.empty else None,
                "Volatility": round(float(volatility(self.strategy_returns)), 4) if self.strategy_returns is not None else None,
            }
        except Exception as e:
            # Fallback: prevent 400 errors
            self.metrics = {"error": f"Metric calculation failed: {str(e)}"}

        return self.metrics
